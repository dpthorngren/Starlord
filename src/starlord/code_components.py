from __future__ import annotations

import re
from dataclasses import dataclass


class Symb(str):
    '''Represents a single symbol or constant in the code generator.'''

    def __new__(cls, source: str | float | int) -> Symb:
        if type(source) is str and re.fullmatch(r"[pcl]\.[A-Za-z_]\w*", source) is not None:
            return super().__new__(cls, source)
        try:
            value: float = float(source)
        except ValueError:
            raise ValueError(f'Could not interpret "{source}" as a symbol or literal.') from None
        return super().__new__(cls, str(value))

    @property
    def name(self) -> str:
        return self[2:]

    @property
    def label(self) -> str:
        return self[0]

    @property
    def var(self) -> str:
        return self.label + "_" + self.name

    def is_literal(self) -> bool:
        try:
            float(self)
            return True
        except ValueError:
            return False


@dataclass(frozen=True)
class Component:
    '''Represents a section of code for CodeGenerator.'''
    requires: set[Symb]
    provides: set[Symb]
    code: str
    autogenerated: bool

    def __repr__(self) -> str:
        return self.code + " [Expr]"

    def generate_code(self) -> str:
        return self.code


@dataclass(frozen=True)
class AssignmentComponent(Component):

    @classmethod
    def create(cls, var: Symb, expr: str, requires: set[Symb], autogenerated: bool = False):
        assert var.label in "lb"
        return cls(requires, set([var]), expr, autogenerated)

    def __repr__(self) -> str:
        return f"{{{list(self.provides)[0]}}} = {self.code}"

    def generate_code(self) -> str:
        code: str = f"{{{list(self.provides)[0]}}} = {self.code}"
        return code


@dataclass(frozen=True)
class DistributionComponent(Component):
    params: list[str]
    var: Symb

    @classmethod
    def create(cls, var: Symb, dist: str, params: list[Symb], autogenerated: bool = False):
        dist = dist.lower()
        assert dist in ["normal", "uniform", "beta", "gamma"]
        requires: set[Symb] = set(p for p in params if not p.is_literal())
        requires = requires | {var}
        pars = [str(p) if p.is_literal() else f"{{{p}}}" for p in params]
        return cls(requires, set(), dist, autogenerated, pars, var)

    def __repr__(self) -> str:
        # Literals (strings not starting with "{" need brackets added for formatting.
        params = [p if p.startswith("{") else f"{{{p}}}" for p in self.params]
        return f"{self.code.title()}({{{self.var}}} | {', '.join(params)})"

    def generate_code(self) -> str:
        return f"logL += {self.code}_lpdf({{{self.var}}}, {', '.join(self.params)})"


@dataclass(frozen=True)
class Prior:
    vars: list[Symb]
    code_ppf: str
    code_pdf: str
    params: list[Symb]
    distribution: str

    @property
    def requires(self) -> set[Symb]:
        return set()

    @property
    def provides(self) -> set[Symb]:
        return set(self.vars)

    @classmethod
    def create(cls, var: Symb, distribution: str, params: list[Symb]):
        distribution = distribution.lower()
        assert distribution in ["normal", "uniform", "beta", "gamma"]
        return Prior(
            vars=[var],
            code_ppf="{{{vars[0]}}} = " + distribution + "_ppf({{{vars[0]}}}, {paramStr})",
            code_pdf="logP += " + distribution + "_lpdf({{{vars[0]}}}, {paramStr})",
            params=params,
            distribution=distribution,
        )

    def __repr__(self) -> str:
        # Literals (strings not starting with "{" need brackets added for formatting.
        vars = [f"{{{v}}}" for v in self.vars]
        params = [p if p.startswith("{") else f"{{{p}}}" for p in self.params]
        return f"{self.distribution.title()}({', '.join(vars)} | {', '.join(params)})"

    def generate_ppf(self) -> str:
        fmt = dict(vars=self.vars, params=self.params, paramStr=", ".join(self.params))
        return self.code_ppf.format(**fmt)

    def generate_pdf(self) -> str:
        fmt = dict(vars=self.vars, params=self.params, paramStr=", ".join(self.params))
        return self.code_pdf.format(**fmt)
