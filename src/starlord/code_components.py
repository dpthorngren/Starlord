from __future__ import annotations

import re
from dataclasses import dataclass
from typing import Optional


class Symb(str):
    '''Represents a single symbol or constant in the code generator.'''

    def __new__(cls, source: str | float | int) -> Symb:
        if type(source) is str and re.fullmatch(r"[pcbl]\.[A-Za-z_]\w*", source) is not None:
            return super().__new__(cls, source)
        try:
            value: float = float(source)
        except ValueError:
            raise ValueError(f'Could not interpret "{source}" as a symbol or literal.') from None
        return super().__new__(cls, str(value))

    @property
    def name(self) -> str:
        return self[2:]

    @property
    def label(self) -> str:
        return self[0]

    @property
    def var(self) -> str:
        return self.label + "_" + self.name

    def is_literal(self) -> bool:
        try:
            float(self)
            return True
        except ValueError:
            return False


@dataclass(frozen=True)
class Component:
    '''Represents a section of code for CodeGenerator.'''
    requires: set[Symb]
    provides: set[Symb]
    code: str
    autogenerated: bool

    def __repr__(self) -> str:
        return self.code + " [Expr]"

    def generate_code(self, prior_type: Optional[str] = None) -> str:
        return self.code


@dataclass(frozen=True)
class AssignmentComponent(Component):

    @classmethod
    def create(cls, var: Symb, expr: str, requires: set[Symb], autogenerated: bool = False):
        assert var.label in "lb"
        return cls(requires, set([var]), expr, autogenerated)

    def __repr__(self) -> str:
        return f"{{{list(self.provides)[0]}}} = {self.code}"

    def generate_code(self, prior_type: Optional[str] = None) -> str:
        code: str = f"{{{list(self.provides)[0]}}} = {self.code}"
        return code


@dataclass(frozen=True)
class DistributionComponent(Component):
    params: list[str]
    var: Symb

    @classmethod
    def create(cls, var: Symb, dist: str, params: list[Symb], autogenerated: bool = False):
        dist = dist.lower()
        assert dist in ["normal", "uniform", "beta", "gamma"]
        requires: set[Symb] = set(p for p in params if not p.is_literal())
        requires = requires | {var}
        pars = [str(p) if p.is_literal() else f"{{{p}}}" for p in params]
        return cls(requires, set(), dist, autogenerated, pars, var)

    def __repr__(self) -> str:
        # Literals (strings not starting with "{" need brackets added for formatting.
        params = [p if p.startswith("{") else f"{{{p}}}" for p in self.params]
        return f"{self.code.title()}({{{self.var}}} | {', '.join(params)})"

    def generate_code(self, prior_type: Optional[str] = None) -> str:
        if prior_type is None:
            result = f"logL += {self.code}_lpdf({{{self.var}}}, {', '.join(self.params)})"
        elif prior_type == "pdf":
            result = f"logP += {self.code}_lpdf({{{self.var}}}, {', '.join(self.params)})"
        elif prior_type == "ppf":
            result = f"{{{self.var}}} = {self.code}_ppf({{{self.var}}}, {', '.join(self.params)})"
        else:
            raise ValueError(f"Unrecognized prior option {prior_type} -- must be None, 'ppf', or 'pdf'.")
        return result
